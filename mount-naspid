#!/bin/bash
#set -x

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
#
# MOUNT-MANAGER
# 
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
#
# CONTROLS USER DEFINED MOUNTS
# SUPPORTED MOUNT TYPES: SSHFS, SAMBA, DEVICE
#
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
#-----####--#-------###---####----###---#-------####-------------------------#
#----#------#------#---#--#---#--#---#--#------#-----------------------------#
#----#--##--#------#---#--####---#####--#-------###--------------------------#
#----#---#--#------#---#--#---#--#---#--#----------#-------------------------#
#-----####--#####---###---####---#---#--#####--####--------------------------#
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
# control options
CONTROL_FILE="/tmp/pinasd.control"

# daemon options
CHECK_INTERVAL=2
ROOT_UID=0

# mount options
MOUNT_PATH="/media"
FSTAB_DIR="/etc/fstab.d"

# fstab options
PATH_TO_SOURCE_DATA="/home/media/naspi/modules/files/sources/./sourcedata"

DEVICE_DEFAULTS='auto noauto,defaults'

SMB_CREDENTIALS='/root/.credentials'
SMB_DEFAULTS='cifs noexec,noauto,defaults,user,credentials='

SSH_CREDENTIALS='/root/.credentials'

# errors and messages
E_NOTROOT=69
BAD_DATA="ERROR: Empty data found"
BAD_DEVICE="ERROR: Device not connected"
BAD_CONTROL="ERROR: Contol file empty"
BAD_USAGE="ERROR: Invalid usage use --help to show usage"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
#----#####--#---#--#---#---####--#####--#####---###---#---#---####-----------#
#----#------#---#--##--#--#--------#------#----#---#--##--#--#---------------#
#----###----#---#--#-#-#--#--------#------#----#---#--#-#-#---###------------#
#----#------#---#--#--##--#--------#------#----#---#--#--##------#-----------#
#----#-------###---#---#---####----#----#####---###---#---#--####------------#
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
# Prevents multiple running instances by checking for itself
function already_running() {
	SCRIPT_NAME=$(basename "$(test -L "$0" && readlink "$0" || echo "$0")")
	DAEMON_PID=$(pidof -x -o%PPID "$SCRIPT_NAME")
	if [[ -n  $DAEMON_PID ]]; then
		echo -e "Daemon already running.\n$DAEMON_PID"
		exit 
	fi
}
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
# Check userid to ensure it is run as root
function must_be_root() {
	if [ "$UID" -ne "$ROOT_UID" ]; then
		echo "Must be run as root" 1>&2
		exit $E_NOTROOT
	fi
}
# Check that specified device is attached
function device_test() {
	DEVICE_TEST=$(blkid | grep $1)
	if [[ -z $DEVICE_TEST ]]; then
		echo $BAD_DEVICE
	fi
}
# Make directory if it doesn't exist
function create_missing_directory() {
	if [[ ! -e $1 ]] && [[ ! -d $1 ]]; then
		mkdir "$1"
	fi
}
# Run external script to query web interface for data
function get_data() {
	#set -x
	DATA=$PATH_TO_SOURCE_DATA $MOUNT $1
	if [[ -z $DATA ]]; then
		echo "$BAD_DATA $1 for $MOUNT" 1>&2
	else
		echo $DATA
	fi
}
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
#----###-----###---#####--#---#---###---#---#--------------------------------#
#----#--#---#---#--#------##-##--#---#--##--#--------------------------------#
#----#---#--#####--###----#-#-#--#---#--#-#-#--------------------------------#
#----#--#---#---#--#------#---#--#---#--#--##--------------------------------#
#----###----#---#--#####--#---#---###---#---#--------------------------------#
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
function start_daemon()
{
	must_be_root
	already_running
	create_missing_directory $FSTAB_DIR
	while [[ true ]]; do
		if [[ -e $CONTROL_FILE ]]; then
			MOUNT=$(cat $CONTROL_FILE)
			rm $CONTROL_FILE
			if [[ -n $MOUNT ]]; then
				write_fstab $MOUNT
				mount_filesystem $MOUNT
			else
				echo "$BAD_CONTROL" 1>&2
			fi
		fi
		sleep $CHECK_INTERVAL
	done
}
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
#----#####---####--#####---###---###-----------------------------------------#
#----#------#--------#----#---#--#--#----------------------------------------#
#----###-----###-----#----#####--####----------------------------------------#
#----#----------#----#----#---#--#---#---------------------------------------#
#----#------####-----#----#---#--####----------------------------------------#
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
function device_fstab()
{		
	#set -x
	UUID=$(get_data $1 UUID)
	SOURCE=$(get_data $1 SourceCode)
	# Write device fstab to file
	echo "UUID=${UUID} \
	${MOUNT_PATH}/${SOURCE} \
	${DEVICE_DEFAULTS} \
	0 0" \
	> ${FSTAB_DIR}/${1}.fstab
}
function bind_fstab()
{
		SOURCE=$(get_data $1 SourceCode)
		
}
function smb_fstab()
{
	#set -x
	SMB1=$(get_data RemoteHost)
	SMB2=$(get_data RemotePath)
	SMB3=$(get_data SourceCode)
	SMB_U=$(get_data Username)
	SMB_P=$(get_data Password)
	#set -x
	echo "username=${SMB_U}\npassword=${SMB_P}" \
	> ${SMB_CREDENTIALS}/${1}.smb
	
	echo "//${SMB1}${SMB2// /\\040} \
	${MOUNT_PATH}/${SMB3} \
	${SMB_DEFAULTS}${SMB_CREDENTIALS}/$1.smb \
	0 0" \
	> ${FSTAB_DIR}/$1.fstab
}
function sshfs_fstab()
{
	SSH_HOST=$(get_data RemoteHost)
	SSH_PORT=$(get_data Port)
	SSH_PATH=$(get_data RemotePath)
	SSH_SC=$(get_data SourceCode)
	SSH_U=$(get_data Username)
	SSH_P=$(get_data Password)
	# Create the ssh credentials file
	echo "${SSH_P}" \
	> ${SSH_CREDENTIALS}/${1}.sshfs
	
	# Write shell script to mount sshfs
	echo "sshfs $SSH_U@$SSH_HOST:$SSH_PATH \
	-p $SSH_PORT \
	-o password_stdin \
	-o allow_other \
	-o StrictHostKeyChecking=no \
	/media/$MOUNT" \
	> ${FSTAB_DIR}/$1-sshfs.sh
	
	# Write a psuedo fstab entry for sshfs share
	echo "sshfs#${SSH_U}@${SSH_HOST}:/${SSH_PATH// /\\040} \
	${MOUNT_PATH// /\\040}/${SSH_SC} \
	fuse \
	comment=sshfs,noauto,users,allow_other \
	0	0" \
	> ${FSTAB_DIR}/$1.fstab
}
function write_fstab()
{
	if [[ -n $MOUNT ]];then
		TYPE=$(get_data FSType)
		if [[ $TYPE = device ]]; then
			device_fstab $MOUNT
		fi
		if [[ $TYPE = smb ]]; then
			smb_fstab $MOUNT
		fi
		if [[ $TYPE = sshfs ]]; then
			sshfs_fstab $MOUNT
		fi
		cat $FSTAB_DIR/headfstab $FSTAB_DIR/*.fstab \
		> ${FSTAB_DIR}/fullstab
		cat $FSTAB_DIR/fullstab > /etc/fstab
		echo "Wrote $MOUNT to fstab"
	fi
}
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
#----#---#---###---#---#--#---#--#####---------------------------------------#
#----##-##--#---#--#---#--##--#----#-----------------------------------------#
#----#-#-#--#---#--#---#--#-#-#----#-----------------------------------------#
#----#---#--#---#--#---#--#--##----#-----------------------------------------#
#----#---#---###----###---#---#----#-----------------------------------------#
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
function mount_filesystem() {
	#set -x
	FSTYPE=$(get_data FSType)
	IS_MOUNTED=$(mount -l | grep "on $USE_PATH ")
	IS_ENABLED=$(get_data Enabled)
	
	# Not Mounted
	if [[ -z $IS_MOUNTED ]]; then
		# Enabled
		if [[ -n $IS_ENABLED ]]; then
			create_missing_directory "/media/$MOUNT"
			# sshfs
			if [[ $FSTYPE = sshfs ]]; then
				SSHFS_SCRIPT=$(cat ${FSTAB_DIR}/$MOUNT-sshfs.sh)
				$SSHFS_SCRIPT < $SSH_CREDENTIALS/$MOUNT.sshfs
			# All others
			else
				mount "/media/$MOUNT"
			fi
		# Disabled
		else
			echo "$MOUNT is not mounted and disabled"
		fi
	# Mounted
	else
		# Disabled
		if [[ -z $IS_ENABLED ]]; then
			if [[ $FSTYPE = sshfs ]]; then
			fusermount -u $MOUNT_PATH/$MOUNT
			umount "/media/$MOUNT"
		# Enabled
		else
			echo "$MOUNT is mounted and enabled"
		fi
	fi
}
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
# Sends command line options to control file
function send_control(){
	if [[ ! -e $CONTROL_FILE ]]; then
		echo $MOUNT > $CONTROL_FILE
	fi
}

function remove_source(){
		echo "Remove source not implemented."
}
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
# PARSE COMMAND LINE ARGUMENTS FOR THE CORESPONDING FUNCTION
#set -x

# checks for a running daemon if no arguments given
if [[ -z $1 ]];then
	already_running
	echo "Daemon not running"
fi

case $1 in
	start)
		start_daemon
		;;
	control)
		send_control $2
		;;
	remove)
		remove_source $2
		;;
	*)
		echo "$BAD_USAGE" 1>&2
		echo "$USAGE "
		;;		
esac
