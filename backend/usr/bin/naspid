#!/bin/bash
#set -x
# Includes configuration files, if they exist
# The package defaults, then the global configuration, and last
# in the user directory.  The last read config file overwrites all
# other variables allowing more user end tweaks.  Be careful on the user's
# directory, it may need to be a full path without the ~/

PROG=${0##*/}
SRC_PATH=/etc/naspi/${PROG}.d

CONTROL_FILE="/tmp/naspid.control"
NASPID_LOCK_FILE=/var/lock/${PROG}.lock

. /etc/naspi/errors

CONFIG_SET=FALSE
CONFIG_PATHS=("/etc/naspi" '~' '~/naspi')

for EACH_CONFIG in "${CONFIG_PATHS[@]}"; do
	
	if [[ -f $EACH_CONFIG/$PROG.conf ]]; then
		. "$EACH_CONFIG/$PROG.conf"
		CONFIG_SET=TRUE
	fi

done

if [[ $CONFIG_SET = FALSE ]]; then
	error $E_CONFIG $M_CONFIG
fi

set +x
# PARSE COMMAND LINE ARGUMENTS FOR THE CORESPONDING FUNCTION
#set -x

if [[ -z $1 ]];then
	already_running
	echo "Daemon not running"
fi

#
#
#
function create_missing_directory() {
	#set -x
	if [[ ! -e $1 ]] && [[ ! -d $1 ]]; then
		echo "Created directory: $1"
		mkdir -p "$1"
	fi
	set +x
}

#
# Run external script to query web interface for data
#
function get_data() {
	#set -x
	$GET_DATA $1 $2
	set +x
}

#
#
#
function stop_service(){

	# set -x
	set -f;IFS=$'\n'
	ps=($(ps -e | grep -e ' naspid$' -e ' cat$'))
	ps=(${ps[@]%%[?|p]*})
	unset IFS;set +f
	
	kill $(echo ${ps[@]% *})
	export RUN=FALSE
	
	set +x
}

#
#
#
function input() {
        # set -x
        case $1 in
                commit )
                        . $SRC_PATH/$1.inc $2
                        ;;
                update )
                        . $SRC_PATH/$1.inc $2
                        ;;
                remove )
                        remove_source
                        ;;
                *)
                        echo "${INPUT[@]}"
                        #echo $E_CONTROL
                        #exit
                        ;;
        esac
        set +x
}

#
#
#
function start_service(){
	# set -x
	
	RUN=TRUE
	
	echo "Starting Listener" >> $LOG
	echo $PPID >> $NASPID_LOCK_FILE
	
	mkfifo -m 0600 $CONTROL_FILE
	chown "$USER:$USER" $CONTROL_FILE
	
	while [[ $RUN = TRUE ]]; do
	        INPUT=($(cat $CONTROL_FILE))
		echo "sending ${INPUT[@]}" >> $LOG
		input ${INPUT[@]}
	done

	set +x
}

#
#
#
case $1 in
	start)
		trap 'rm $NASPID_LOCK_FILE $CONTROL_FILE && exit' EXIT INT
		$1_service
		;;
	stop)
		$1_service
		;;
	*)
		echo "$BAD_USAGE" 1>&2
		echo "$USAGE "
		;;		
esac
